# Consider all integer combinations of a**b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

# 2**2=4,  2**3=8,   2**4=16,  2**5=32
# 3**2=9,  3**3=27,  3**4=81,  3**5=243
# 4**2=16, 4**3=64,  4**4=256, 4**5=1024
# 5**2=25, 5**3=125, 5**4=625, 5**5=3125
# If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

# How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

# Is this to do with prime factors? Does it break down to if 2 combinations bring up the same prime factor set you can ignore it without 
# even needing to calculate the big number? My observation from above is 2**4 == 4**2 == 2x2x2x2 and 4**3 == 8**2 == 2x2x2x2x2x2
# I wonder if we can identify the pattern without running the to power of calculation to remove duplicates so we'd do 2:100 * 2:100 - dupes to get the answer?
# I wonder if it's only worth doing this on the non-prime lines. I.e. will the line of 5 to power of ever overlap with another prime? I think not...
# Or is that more work than brute force iteration?

# Baseline the brute force method first then try something smarter:
terms = []
iterations = 100
a = 2
b_start = 2
while a <= iterations:
    b = b_start
    while b <= iterations:
        product = a ** b
        if product not in terms:
            terms.append(a ** b)
        b += 1
    a += 1
print(len(terms))

# Hmm this was really fast should I try and optimise at all?
from math import sqrt
from math import floor
def is_prime(n):
    # If n is negative flip to positive
    if n < 0:
        n = n * - 1
    if n == 1:
        return False
    elif n < 4:
        return True
    elif n % 2 == 0:
        return False
    elif n < 9:
        return True
    elif n % 3 == 0:
        return False
    else:
        r = floor(sqrt(n))
        f = 5
        while f <= r:
            if n % f == 0:
                return False
            if n % (f+2) == 0:
                return False
            f = f + 6
        return True

primes = []
for i in range (2, 100):
    if is_prime(i):
        primes.append(i)

print(len(primes))